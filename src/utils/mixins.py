import base64
import hashlib
import hmac
import logging
from datetime import timedelta

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.mixins import PermissionRequiredMixin, UserPassesTestMixin
from django.core.exceptions import PermissionDenied
from django.utils import timezone
from django.utils.dateparse import parse_datetime

logger = logging.getLogger("bornhack.%s" % __name__)


class StaffMemberRequiredMixin(object):
    """
    A CBV mixin for when a view should only be permitted for staff users
    """

    def dispatch(self, request, *args, **kwargs):
        # only permit staff users
        if not request.user.is_staff:
            messages.error(request, "No thanks")
            raise PermissionDenied()

        # continue with the request
        return super().dispatch(request, *args, **kwargs)


class RaisePermissionRequiredMixin(PermissionRequiredMixin):
    """
    A subclass of PermissionRequiredMixin which raises an exception to return 403 rather than a redirect to the login page
    We use this to avoid a redirect loop since our login page redirects back to the ?next= url when a user is logged in...
    """

    raise_exception = True


class UserIsObjectOwnerMixin(UserPassesTestMixin):
    def test_func(self):
        return self.get_object().user == self.request.user


class RequireHmacAuthMixin:
    """
    This mixin is used for HMAC api auth.

    The HTTP request must contain two headers, containing timestamp and authorization. The authorization
    header contains a username:signature where the signature is based on a shared secret. Example headers:

    - X-BornHmac-Timestamp: 2020-03-02T14:50:11+01:00
    - Authorization: BORNHMAC testapiuser:MzNmYjY4NGVjMDhlMDJhM2JhMjUwOGRiMGJlN2QxNTE4MzI1NTUyZDc2ZTA0MzdiN2VlNjkyZWQ2NGQxZDZlZWU0YWFiZDUyMzUyMGVmYzhkMmQwMzQxZDc3OGVhYTY3NDJlNGZmMzBkN2RkNjFjMjMyZmMzYjJmNmQ3NDlkOWU=

    The timestamp is in iso8601 UTC format - strftime("%Y-%m-%dT%H:%M:%SZ", gmtime())
    The signature is a base64 encoded hexdigest of a sha512 hmac signature of the message "method\ntimestamp\npath"

    An example of a cURL request where the signature is generated by OpenSSL:

        METHOD="GET"
        USERNAME="testapiuser"
        APIKEY="secret123"
        URLPATH="/bornhack-2020/phonebook/csv/"
        NOW="$(date --iso-8601=seconds)"
        SIGNATURE=$(echo -ne "${METHOD}\\n${NOW}\\n${URLPATH}" | openssl dgst -sha512 -hmac key:${APIKEY} | cut -d " " -f 2 | tr -d "\n" | base64 -w 0)
        curl -sH "authorization: BORNHMAC ${USERNAME}:${SIGNATURE}" -H "X-BornHmac-Timestamp: ${NOW}" http://127.0.0.1:8000${URLPATH}

    The API keys are configured in settings as username:apikey pairs.
    """

    def setup(self, *args, **kwargs):
        super().setup(*args, **kwargs)

        # do we have any API keys?
        if not hasattr(settings, "API_KEYS"):
            logger.error("No API keys found in settings, returning 403!")
            raise PermissionDenied("No API keys found in settings\n")

        # check API auth headers
        if (
            "HTTP_X_BORNHMAC_TIMESTAMP" not in self.request.META
            or "HTTP_AUTHORIZATION" not in self.request.META
        ):
            logger.error(
                "X-BornHmac-Timestamp: or Authorization: header missing from API request, returning 403!"
            )
            raise PermissionDenied(
                "X-BornHmac-Timestamp: or Authorization: header missing from API request\n"
            )

        # get request timestamp from header
        authorization_datetime = parse_datetime(
            self.request.META["HTTP_X_BORNHMAC_TIMESTAMP"]
        )
        current_datetime = timezone.now()

        # check if the request timestamp is in the future
        if authorization_datetime > current_datetime:
            logger.error("API request timestamp is in the future, returning 403!")
            raise PermissionDenied("API request timestamp is in the future\n")

        # check how old the request timestamp is
        request_age = current_datetime - authorization_datetime
        if request_age > timedelta(minutes=1):
            logger.error("API request timestamp is too old, returning 403!")
            raise PermissionDenied("API request timestamp is too old\n")

        # get username and signature from Authorization: header
        authorization_username, authorization_signature = (
            self.request.META["HTTP_AUTHORIZATION"].split(" ")[1].split(":")
        )

        # get api secret if the username is valid
        if authorization_username in settings.API_KEYS:
            apikey = settings.API_KEYS[authorization_username].encode("utf-8")
        else:
            logger.error("Unknown API username, returning 403!")
            raise PermissionDenied()

        # Calculate what the signature SHOULD be, using the request method, timestamp (from the request, not our local),
        # and the URI as message
        message = f"{self.request.META['REQUEST_METHOD']}\n{self.request.META['HTTP_X_BORNHMAC_TIMESTAMP']}\n{self.request.path}".encode(
            "utf-8"
        )
        calculated_signature = base64.b64encode(
            hmac.new(apikey, message, hashlib.sha512).hexdigest().encode()
        ).decode()

        # compare the calculated signature to the request signature
        if authorization_signature != calculated_signature:
            logger.error("API request failed validation, returning 403!")
            raise PermissionDenied()

        # auth OK
